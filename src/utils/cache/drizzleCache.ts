import { env } from "cloudflare:workers";
import { is, Table, getTableName } from "drizzle-orm";
import { Cache } from "drizzle-orm/cache/core";
import type { CacheConfig } from "drizzle-orm/cache/core/types";
import { CacheDurableObject } from "./durableobjects/cacheDurableObject";
import { Context } from "hono";
import { Bindings } from "@otypes/bindings";

// Configuration constants
const DISABLE_CACHE = env.DISABLE_CACHE === "true";
const DEFAULT_TTL_SECONDS = 1000;
const DEFAULT_CACHE_NAME = "drizzle-cache";

// Log cache status on module initialization
console.log(`üîß Cache is ${DISABLE_CACHE ? "disabled" : "enabled"} (DISABLE_CACHE=${env.DISABLE_CACHE})`);

/**
 * Cache statistics interface
 */
interface CacheStats {
    totalEntries: number;
    expiredEntries: number;
}

/**
 * Parameters for cache invalidation operations
 */
interface MutationParams {
    tags: string | string[];
    tables: string | string[] | Table<any> | Table<any>[];
}

/**
 * Cloudflare Durable Object-based cache implementation for Drizzle ORM
 * 
 * This cache uses Cloudflare Durable Objects to provide distributed, persistent caching
 * across the Cloudflare edge network. It supports intelligent invalidation based on
 * database tables and custom tags.
 * 
 * Features:
 * - Distributed caching via Cloudflare Durable Objects
 * - Table-based cache invalidation
 * - Tag-based cache invalidation
 * - Configurable TTL per cache entry
 * - Environment-based cache disabling for development
 * - Comprehensive error handling and logging
 * 
 * @example
 * ```typescript
 * const cache = new CloudflareDurableObjectRPCDrizzleCache(
 *   env.CACHE_DO,
 *   "my-cache",
 *   "user-123"
 * );
 * 
 * const db = drizzle(connectionString, { cache });
 * ```
 */
export class CloudflareDurableObjectRPCDrizzleCache extends Cache {
    private readonly globalTtl: number;
    private readonly durableObject: DurableObjectStub<CacheDurableObject>;
    private readonly cacheIdentifier: string;
    private cacheHealthy: boolean = true;
    private lastHealthCheck: number = 0;

    /**
     * Creates a new Cloudflare Durable Object cache instance
     * 
     * @param durableObjectNamespace - The Durable Object namespace for cache operations
     * @param cacheName - Unique name for this cache instance (default: "drizzle-cache")
     * @param cacheIdentifier - Unique identifier to prefix all cache keys (e.g., user ID, tenant ID)
     * @param globalTtl - Default TTL for cache entries in seconds (default: 1000)
     */
    constructor(
        c: Context<{ Bindings: Bindings, Variables: { cacheIdentifier: string } }>,
        cacheName: string = DEFAULT_CACHE_NAME,
        cacheIdentifier: string,
        globalTtl: number = DEFAULT_TTL_SECONDS
    ) {
        super();
        
        this.globalTtl = globalTtl;
        this.cacheIdentifier = cacheIdentifier;
        
        // Create a consistent Durable Object ID for this cache instance
        const durableObjectId = c.env.CACHE_DO.idFromName(cacheName);
        this.durableObject = c.env.CACHE_DO.get(durableObjectId);
    }

    /**
     * Defines the caching strategy for Drizzle ORM
     * 
     * @returns "all" - All queries are cached automatically
     * @returns "explicit" - Only queries with .$withCache() are cached
     */
    strategy(): "explicit" | "all" {
        return "all";
    }

    /**
     * Retrieves cached data for a given query key
     * 
     * @param key - The cache key (generated by Drizzle from query + parameters)
     * @returns The cached query results or undefined if not found/expired
     * 
     * @example
     * ```typescript
     * const cachedResult = await cache.get("users:select:123");
     * ```
     */
    override async get(key: string): Promise<any[] | undefined> {
        const prefixedKey = this.buildCacheKey(key);

        if (DISABLE_CACHE) {
            console.log(`üö´ Cache GET disabled - Key: ${prefixedKey}`);
            return undefined;
        }

        try {
            const result = await this.durableObject.getCacheEntry(prefixedKey);
            
            if (result) {
                console.log(`üéØ Cache HIT - Key: ${prefixedKey}`);
                this.cacheHealthy = true;
            } else {
                console.log(`‚ùå Cache MISS - Key: ${prefixedKey}`);
            }
            
            return result ?? undefined;
        } catch (error) {
            console.error(`‚ùó Cache GET error for key "${prefixedKey}":`, error);
            this.cacheHealthy = false;
            this.lastHealthCheck = Date.now();
            
            // Always return undefined for cache errors to let queries proceed without cache
            return undefined;
        }
    }

    /**
     * Stores query results in the cache
     * 
     * @param key - The cache key (generated by Drizzle)
     * @param response - The query results to cache
     * @param tables - Database tables involved in the query (for invalidation)
     * @param isTag - Whether this is a tagged cache entry
     * @param config - Cache configuration options (TTL, etc.)
     * 
     * @example
     * ```typescript
     * await cache.put("users:select:123", userData, ["users"], false, { ex: 3600 });
     * ```
     */
    override async put(
        key: string,
        response: any,
        tables: string[],
        isTag: boolean,
        config?: CacheConfig,
    ): Promise<void> {
        const prefixedKey = this.buildCacheKey(key);
        
        if (DISABLE_CACHE) {
            console.log(`üö´ Cache PUT disabled - Key: ${prefixedKey}, Tables: [${tables.join(', ')}]`);
            return;
        }

        try {
            const ttl = config?.ex ?? this.globalTtl;
            const serializedResponse = JSON.stringify(response);

            // Add timeout to prevent 30-second hangs
            await Promise.race([
                this.durableObject.putCacheEntry(
                    prefixedKey,
                    serializedResponse,
                    tables,
                    ttl
                ),
                new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Cache PUT RPC timeout after 10 seconds')), 10000)
                )
            ]);

            console.log(`üíæ Cache PUT - Key: ${prefixedKey}, Tables: [${tables.join(', ')}], TTL: ${ttl}s, Size: ${serializedResponse.length} bytes`);
        } catch (error) {
            console.error(`‚ùó Cache PUT error for key "${prefixedKey}":`, error);
        }
    }

    /**
     * Handles cache invalidation when database mutations occur
     * 
     * This method is automatically called by Drizzle ORM when INSERT, UPDATE,
     * or DELETE operations are performed. It invalidates cache entries based on
     * affected tables and custom tags.
     * 
     * @param params - Invalidation parameters containing tables and tags
     * 
     * @example
     * ```typescript
     * // Automatically called by Drizzle on mutations
     * await cache.onMutate({
     *   tables: ["users", "profiles"],
     *   tags: ["user-data"]
     * });
     * ```
     */
    override async onMutate(params: MutationParams): Promise<void> {
        const { normalizedTags, normalizedTables } = this.normalizeInvalidationParams(params);
        
        if (DISABLE_CACHE) {
            console.log(`üö´ Cache INVALIDATION disabled - Tables: [${normalizedTables.join(', ')}], Tags: [${normalizedTags.join(', ')}]`);
            return;
        }

        try {
            console.log(`üóëÔ∏è  Cache INVALIDATION started - Tables: [${normalizedTables.join(', ')}], Tags: [${normalizedTags.join(', ')}]`);

            const invalidationPromises: Promise<any>[] = [];

            // Invalidate by tables if any are provided
            if (normalizedTables.length > 0) {
                invalidationPromises.push(this.durableObject.invalidateByTables(normalizedTables));
            }

            const results = await Promise.allSettled(invalidationPromises);
            
            // Log results
            results.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    const deletedCount = typeof result.value === 'number' ? result.value : 'unknown';
                    console.log(`‚úÖ Cache invalidation completed - Operation ${index + 1}: ${deletedCount} entries deleted`);
                } else {
                    console.error(`‚ùó Cache invalidation failed - Operation ${index + 1}:`, result.reason);
                }
            });
            
        } catch (error) {
            console.error('‚ùó Cache invalidation error:', error);
        }
    }

    /**
     * Retrieves cache statistics
     * 
     * @returns Cache statistics including total and expired entries
     * 
     * @example
     * ```typescript
     * const stats = await cache.getCacheStats();
     * console.log(`Cache has ${stats.totalEntries} total entries, ${stats.expiredEntries} expired`);
     * ```
     */
    async getCacheStats(): Promise<CacheStats> {
        try {
            const stats = await this.durableObject.getCacheStats();
            console.log(`üìä Cache stats retrieved - Total: ${stats.totalEntries}, Expired: ${stats.expiredEntries}`);
            return stats;
        } catch (error) {
            console.error('‚ùó Cache stats error:', error);
            return { totalEntries: 0, expiredEntries: 0 };
        }
    }

    /**
     * Manually triggers cleanup of expired cache entries
     * 
     * This is useful for maintenance operations and memory management.
     * The Durable Object may also perform automatic cleanup.
     * 
     * @example
     * ```typescript
     * await cache.cleanup();
     * ```
     */
    async cleanup(): Promise<void> {
        try {
            await this.durableObject.cleanupExpiredEntries();
            console.log('üßπ Cache cleanup completed successfully');
        } catch (error) {
            console.error('‚ùó Cache cleanup error:', error);
        }
    }

    /**
     * Builds a cache key with the configured prefix
     * 
     * @private
     * @param key - The base cache key
     * @returns The prefixed cache key
     */
    private buildCacheKey(key: string): string {
        return `${this.cacheIdentifier}-${key}`;
    }

    /**
     * Normalizes invalidation parameters into consistent arrays
     * 
     * @private
     * @param params - The invalidation parameters
     * @returns Normalized tags and table names
     */
    private normalizeInvalidationParams(params: MutationParams): {
        normalizedTags: string[];
        normalizedTables: string[];
    } {
        // Normalize tags to array
        const normalizedTags = params.tags
            ? Array.isArray(params.tags) ? params.tags : [params.tags]
            : [];

        // Normalize tables to array
        const tablesArray = params.tables
            ? Array.isArray(params.tables) ? params.tables : [params.tables]
            : [];

        // Extract table names from Table objects or use strings directly
        const normalizedTables: string[] = [];
        for (const table of tablesArray) {
            const tableName = is(table, Table)
                ? getTableName(table)
                : (table as string);
            normalizedTables.push(tableName);
        }

        return { normalizedTags, normalizedTables };
    }
}
